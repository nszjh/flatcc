// Example on how to build a Monster FlatBuffer.


// Note: while some older C89 compilers are supported when
// -DFLATCC_PORTABLE is defined, this particular sample is known not to
// not work with MSVC 2010 (MSVC 2013 is OK) due to inline variable
// declarations. These are easily move to the start of code blocks, but
// since we follow the step-wise tutorial, it isn't really practical
// in this case. The comment style is technically also in violation of C89.


#include "nv_sys_param_builder.h" // Generated by `flatcc`.
// <string.h> and <assert.h> already included.

// Convenient namespace macro to manage long namespace prefix.
// The ns macro makes it possible to write `ns(Monster_create(...))`
// instead of `MyGame_Sample_Monster_create(...)`
#undef ns
#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(Nv_ns08, x) // Specified in the schema.

// A helper to simplify creating vectors from C-arrays.
#define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))

// This allows us to verify result in optimized builds.
#define test_assert(x) do { if (!(x)) { assert(0); return -1; }} while(0)

// // Bottom-up approach where we create child objects and store these
// // in temporary references before a parent object is created with
// // these references.
// int create_monster_bottom_up(flatcc_builder_t *B, int flexible)
// {
//     flatbuffers_string_ref_t weapon_one_name = flatbuffers_string_create_str(B, "Sword");
//     int16_t weapon_one_damage = 3;

//     flatbuffers_string_ref_t weapon_two_name = flatbuffers_string_create_str(B, "Axe");
//     int16_t weapon_two_damage = 5;

//     // Use the `MyGame_Sample_Weapon_create` shortcut to create Weapons
//     // with all the fields set.
//     //
//     // In the C-API, verbs (here create) always follow the type name
//     // (here Weapon), prefixed by the namespace (here MyGame_Sample_):
//     // MyGame_Sample_Weapon_create(...), or ns(Weapone_create(...)).
//     ns(Weapon_ref_t) sword = ns(Weapon_create(B, weapon_one_name, weapon_one_damage));
//     ns(Weapon_ref_t) axe = ns(Weapon_create(B, weapon_two_name, weapon_two_damage));

//     // Serialize a name for our monster, called "Orc".
//     // The _str suffix indicates the source is an ascii-z string.
//     flatbuffers_string_ref_t name = flatbuffers_string_create_str(B, "Orc");

//     // Create a `vector` representing the inventory of the Orc. Each number
//     // could correspond to an item that can be claimed after he is slain.
//     uint8_t treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
//     flatbuffers_uint8_vec_ref_t inventory;
//     // `c_vec_len` is the convenience macro we defined earlier.
//     inventory = flatbuffers_uint8_vec_create(B, treasure, c_vec_len(treasure));

//     // Here we use a top-down approach locally to build a Weapons vector
//     // in-place instead of creating a temporary external vector to use
//     // as argument like we did with the `inventory` earlier on, but the
//     // overall approach is still bottom-up.
//     ns(Weapon_vec_start(B));
//     ns(Weapon_vec_push(B, sword));
//     ns(Weapon_vec_push(B, axe));
//     ns(Weapon_vec_ref_t) weapons = ns(Weapon_vec_end(B));


//     // Create a `Vec3`, representing the Orc's position in 3-D space.
//     ns(Vec3_t) pos = { 1.0f, 2.0f, 3.0f };


//     // Set his hit points to 300 and his mana to 150.
//     int16_t hp = 300;
//     // The default value is 150, so we will never store this field.
//     int16_t mana = 15990;

//     // Create the equipment union. In the C++ language API this is given
//     // as two arguments to the create call, or as two separate add
//     // operations for the type and the table reference. Here we create
//     // a single union value that carries both the type and reference.
//     ns(Equipment_union_ref_t) equipped = ns(Equipment_as_Weapon(axe));

//     if (!flexible) {
//         // Finally, create the monster using the `Monster_create` helper function
//         // to set all fields.
//         //
//         // Note that the Equipment union only take up one argument in C, where
//         // C++ takes a type and an object argument.
//         ns(Monster_create_as_root(B, &pos, mana, hp, name, inventory, ns(Color_Red),
//                              weapons, equipped));

//         // Unlike C++ we do not use a Finish call. Instead we use the
//         // `create_as_root` action which has better type safety and
//         // simplicity.
//         //
//         // However, we can also express this as:
//         //
//         // ns(Monster_ref_t) orc = ns(Monster_create(B, ...));
//         // flatcc_builder_buffer_create(orc);
//         //
//         // In this approach the function should return the orc and
//         // let a calling function handle the flatcc_buffer_create call
//         // for a more composable setup that is also able to create child
//         // monsters. In general, `flatcc_builder` calls are best isolated
//         // in a containing driver function.

//     } else {

//         // A more flexible approach where we mix bottom-up and top-down
//         // style. We still create child objects first, but then create
//         // a top-down style monster object that we can manipulate in more
//         // detail.

//         // It is important to pair `start_as_root` with `end_as_root`.
//         ns(Monster_start_as_root(B));
//         ns(Monster_pos_create(B, 1.0f, 2.0f, 3.0f));
//         // or alternatively
//         //ns(Monster_pos_add(&pos);

//         ns(Monster_hp_add(B, hp));
//         // Notice that `Monser_name_add` adds a string reference unlike the
//         // add_str and add_strn variants.
//         ns(Monster_name_add(B, name));
//         ns(Monster_inventory_add(B, inventory));
//         ns(Monster_color_add(B, ns(Color_Red)));
//         ns(Monster_weapons_add(B, weapons));
//         ns(Monster_equipped_add(B, equipped));
//         // Complete the monster object and make it the buffer root object.
//         ns(Monster_end_as_root(B));

//         // We could also drop the `as_root` suffix from Monster_start/end(B)
//         // and add the table as buffer root later:
//         //
//         // ns(Monster_ref_t) orc = ns(Monster_start(B));
//         // ...
//         // ns(Monster_ref_t) orc = ns(Monster_end(B));
//         // flatcc_builder_buffer_create(orc);
//         //
//         // It is best to keep the `flatcc_builder` calls in a containing
//         // driver function for modularity.
//     }
//     return 0;
// }

// Alternative top-down approach where parent objects are created before
// their children. We only need to save one reference because the `axe`
// object is used in two places effectively making the buffer object
// graph a DAG.
int gen_data(flatcc_builder_t *B)
{

    ns(HI_DEV_CFG_t) dev_cfg = {
        .rgb_sensor_type = ns(RgbSensor_IMX327),
        .tof_sensor_type = ns(TofSensor_NV08),
    };

    ns(HI_PARAM_STABLE_INFO_t) stable_info = {
        .struDevCfg = dev_cfg,
        .u32GateWay = {0x1234, 0x6789},
        .u32IPAddr = {0x3333, 0x8888},
    };

    ns(HI_DEV_COMM_CFG_t) comm_cfg = {
        .u8CommId = 0,
        .u32BaudRate = 115200
    };

    ns(HI_DEV_RTSP_CFG_t) rtsp_cfg = {
        .u32Size = 0,
        .u16SvrPort = 554,
        .u8Enable = 1
    };

    // ns(NvSysParam_t) sys_param_t = {
    //     .comm = comm_cfg,
    //     .rtsp = rtsp_cfg,
    //     .stable = stable_info
    // };
    // ns(NvSysParam_t) *pSysParam;

    // NOTE: if we use end_as_root, we MUST also start as root.
    ns(NvSysParam_t) *sys_param_t = ns(NvSysParam_start(B));
    sys_param_t->comm = comm_cfg;
    sys_param_t->rtsp = rtsp_cfg;
    sys_param_t->stable = stable_info;
    ns(NvSysParam_end(B));
    return 0;
}

// This isn't strictly needed because the builder already included the reader,
// but we would need it if our reader were in a separate file.
#include "nv_sys_param_reader.h"
#undef ns


#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(Nv_ns08, x) // Specified in the schema.

int access_monster_buffer(const void *buffer)
{
    // // Note that we use the `table_t` suffix when reading a table object
    // // as opposed to the `ref_t` suffix used during the construction of
    // // the buffer.
    ns(NvSysParam_struct_t) nvsys = ns(NvSysParam_as_root(buffer));
    test_assert(nvsys != 0);

    printf("comm: %d %d\n", nvsys->comm.u8CommId, nvsys->comm.u32BaudRate);
    printf("rtsp: %d\n", nvsys->rtsp.u16SvrPort);

    return 0;
}

#include <stdio.h>

int main(int argc, char *argv[])
{
    // Create a `FlatBufferBuilder`, which will be used to create our
    // monsters' FlatBuffers.
    flatcc_builder_t builder;
    void  *buf;
    size_t size;

    // Silence warnings.
    (void)argc;
    (void)argv;

    // Initialize the builder object.
    flatcc_builder_init(&builder);
    flatcc_builder_reset(&builder);
    // gen data
    gen_data(&builder);
    buf = flatcc_builder_finalize_buffer(&builder, &size);
    FILE *f = fopen("nvsys_param.bin", "wb");
    if (f)
    {
        fwrite(buf, size, 1, f);
        fclose(f);
        f = NULL;
    }
    flatcc_builder_free(buf);
    flatcc_builder_clear(&builder);

    // read data from file
    char *param_buffer = (char *)malloc(sizeof(char) * 1024);
    FILE *f1 = fopen("nvsys_param.bin", "rb");
    if (f1)
    {
        fread(param_buffer, size, 1, f1);
        fclose(f1);
    }
    test_assert(0 == access_monster_buffer(param_buffer));
    // Eventually the builder must be cleaned up:
    printf("The FlatBuffer was successfully created and accessed!\n");
    free(param_buffer);
    
    return 0;
}
